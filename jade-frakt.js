// Generated by CoffeeScript 1.6.3
(function() {
  var Emitter, async, curry, fs, jade, path, _;

  fs = require('fs');

  async = require('async');

  curry = require('naan').curry;

  _ = require('underscore');

  Emitter = require('events').EventEmitter;

  jade = require('jade');

  path = require('path');

  module.exports = function(directory, opts) {
    var fetchTemplates, readQueue, readTemplates, templates, updateTemplates;
    readQueue = async.queue((function(task, callback) {
      return task(callback);
    }), 1);
    templates = null;
    if (opts == null) {
      opts = {};
    }
    if (opts.compile == null) {
      opts.compile = false;
    }
    if (opts.cache == null) {
      opts.cache = true;
    }
    if (opts.expose == null) {
      opts.expose = false;
    }
    readTemplates = function(callback) {
      return fs.readdir(directory, function(err, files) {
        var file, tasks, tolerantReadFile;
        if (err) {
          return callback(err);
        }
        files = _.reject(files, function(file) {
          return file === 'index.jade';
        });
        tolerantReadFile = function(filename, callback) {
          return fs.readFile(filename, function(err, data) {
            if (err) {
              return callback((err.code === 'EISDIR' ? null : err), false);
            } else {
              return callback(null, data);
            }
          });
        };
        tasks = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            file = files[_i];
            _results.push(curry(tolerantReadFile, "" + directory + "/" + file));
          }
          return _results;
        })();
        return async.parallel(tasks, function(err, contents) {
          var data, filename, i, templatesData, _i, _len;
          if (err) {
            return callback(err);
          }
          templatesData = {};
          for (i = _i = 0, _len = contents.length; _i < _len; i = ++_i) {
            data = contents[i];
            if (!data) {
              continue;
            }
            data = data.toString();
            if (opts.compile) {
              data = jade.compile(data, {
                compileDebug: false,
                compileClient: true,
                filename: path.resolve(directory, files[i])
              });
            }
            filename = files[i].replace(/\.jade$/i, "");
            templatesData[filename] = data;
          }
          return callback(null, templatesData);
        });
      });
    };
    updateTemplates = function(callback) {
      return readTemplates(function(err, templatesData) {
        if (err) {
          return callback(err);
        }
        templates = templatesData;
        return callback(null, templates);
      });
    };
    fetchTemplates = !opts.cache ? readTemplates : function(callback) {
      if (templates) {
        return callback(null, templates);
      }
      return updateTemplates(callback);
    };
    if (opts.cache) {
      fs.watch(directory, function() {
        return readQueue.push(updateTemplates, function() {});
      });
    }
    return function(req, res, next) {
      return fetchTemplates(function(err, templates) {
        if (err) {
          return res.send(err, 500);
        }
        if (opts.expose) {
          res.expose(templates, 'templates');
        } else {
          res.local('templates', templates);
        }
        return next();
      });
    };
  };

}).call(this);
